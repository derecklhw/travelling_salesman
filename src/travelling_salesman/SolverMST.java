package travelling_salesman;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
import java.util.HashSet;

/**
 * Utility class for solving the TSP using a MST-based approach.
 */
public class SolverMST {

    /**
     * Solves the TSP using an MST-based approach.
     *
     * @param cities The list of cities to use in the algorithm.
     * @return The solution to the Travelling Salesman Problem.
     */
    public static ArrayList<City> solveMST(ArrayList<City> cities) {
        double[][] adjacencyMatrix = createAdjacencyMatrix(cities);
        int[] parent = constructMST(adjacencyMatrix, cities.size());

        // Perform a preorder walk to create the initial TSP route
        boolean[] visited = new boolean[cities.size()];
        ArrayList<City> initialRoute = new ArrayList<>();
        preorderWalk(0, visited, initialRoute, cities, parent);

        // Apply shortcutting to ensure each city is visited only once
        return applyShortcutting(initialRoute);
    }

    /**
     * Creates an adjacency matrix for the given list of cities, representing the
     * graph.
     * 
     * @param cities The list of cities.
     * @return The adjacency matrix representing distances between cities.
     */
    private static double[][] createAdjacencyMatrix(ArrayList<City> cities) {
        int n = cities.size();
        double[][] adjacencyMatrix = new double[n][n];

        // Fill the adjacency matrix with distances between each pair of cities
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j) {
                    adjacencyMatrix[i][j] = cities.get(i).distanceTo(cities.get(j));
                }
            }
        }
        return adjacencyMatrix;
    }

    /**
     * Constructs a Minimum Spanning Tree (MST) using Prim's algorithm.
     * 
     * @param adjacencyMatrix The adjacency matrix of the graph.
     * @param n               The number of vertices (cities) in the graph.
     * @return An array representing the MST. Each index represents a vertex, and
     *         its value is the parent vertex in the MST.
     */
    private static int[] constructMST(double[][] adjacencyMatrix, int n) {
        int[] parent = new int[n];
        double[] key = new double[n];
        boolean[] mstSet = new boolean[n];

        // Custom comparator for the priority queue based on the key values
        Comparator<Integer> comparator = (index1, index2) -> Double.compare(key[index1], key[index2]);
        PriorityQueue<Integer> pq = new PriorityQueue<>(n, comparator);

        // Initialize all keys as infinite and add all vertices to the priority queue
        Arrays.fill(key, Double.MAX_VALUE);
        for (int i = 0; i < n; i++) {
            pq.add(i);
        }
        key[0] = 0;
        parent[0] = -1;

        // Prim's algorithm to construct the MST
        while (!pq.isEmpty()) {
            int u = pq.poll();
            mstSet[u] = true;

            // Update the key and parent of adjacent vertices
            for (int v = 0; v < n; v++) {
                if (adjacencyMatrix[u][v] != 0 && !mstSet[v] && adjacencyMatrix[u][v] < key[v]) {
                    parent[v] = u;
                    key[v] = adjacencyMatrix[u][v];
                    // Refresh the priority queue
                    pq.remove(v);
                    pq.add(v);
                }
            }
        }
        return parent;
    }

    /**
     * Performs a preorder walk of the MST to create an initial TSP route.
     * 
     * @param currentNode The current node in the walk.
     * @param visited     An array to track visited cities.
     * @param route       The current route being constructed.
     * @param cities      The list of cities.
     * @param parent      An array representing the MST.
     */
    private static void preorderWalk(int currentNode, boolean[] visited, ArrayList<City> route, ArrayList<City> cities,
            int[] parent) {
        visited[currentNode] = true;
        route.add(cities.get(currentNode));

        // Recursively visit all children of the current node in the MST
        for (int i = 0; i < cities.size(); i++) {
            if (parent[i] == currentNode && !visited[i]) {
                preorderWalk(i, visited, route, cities, parent);
            }
        }
    }

    /**
     * Applies shortcutting to the route, ensuring each city is visited only once.
     * 
     * @param route The initial route generated by the preorder walk.
     * @return The optimized route after shortcutting.
     */
    private static ArrayList<City> applyShortcutting(ArrayList<City> route) {
        ArrayList<City> shortcutRoute = new ArrayList<>();
        HashSet<City> visitedCities = new HashSet<>();

        // Add cities to the route, skipping already visited ones
        for (City city : route) {
            if (!visitedCities.contains(city)) {
                visitedCities.add(city);
                shortcutRoute.add(city);
            }
        }
        if (!route.isEmpty()) {
            shortcutRoute.add(route.get(0));
        }

        return shortcutRoute;
    }
}
